@page "/transaction"

@using PET.Models
@using PET.Interfaces
@using PET.Services
@using Blazored.Toast.Services
@using PET.Helper

@inject PreferencesStoreClone Storage
@inject MapUser MapUser

@inject PageTitleService PageTitleService
@inject ITransaction TransactionService
@inject ITag TagService
@inject IUser UserService
@inject NavigationManager Navigation
@inject IToastService ToastService


@if (!string.IsNullOrWhiteSpace(errorMessage))
{
    <div class="alert alert-danger">@errorMessage</div>
}


@* Filter Controls *@
<div class="mb-6">
    <div class="gap-2 grid grid-cols-1 md:grid-cols-5">
        @* Transaction Type Filter *@
        <div class="col-span-1">
            <label for="transactionTypeFilter" class="form-label">Transaction Type:</label>
            <select id="transactionTypeFilter" @bind="transactionTypeFilter" class="form-control">
                <option value="">All</option>
                <option value="Debit">Debit</option>
                <option value="Credit">Credit</option>
            </select>
        </div>

        @* Tag Filter *@
        <div class="col-span-1">
            <label for="tagFilter" class="form-label">Tags:</label>
            <input id="tagFilter" type="text" @bind="tagFilter" class="form-control" list="tagList" />
            <datalist id="tagList">
                <option value="">Select</option>
                @foreach (var tag in AllTags)
                {
                    <option value="@tag.Name" />
                }
            </datalist>
        </div>

        @* Date Range Filter *@
        <div class="col-span-2">
            <label for="dateRangeFilter" class="form-label">Date Range:</label>
            <div class="d-flex">
                <input id="startDateFilter" type="date" @bind="startDateFilter" class="form-control" />
                <span class="mx-2">to</span>
                <input id="endDateFilter" type="date" @bind="endDateFilter" class="form-control" />
            </div>
        </div>

        <div class="col-span-1">
            <br />
            <button class="btn btn-primary h-3/4 w-1/2" @onclick="ApplyFilters">Filter</button>
        </div>
    </div>
</div>

@* Add Transaction Button *@
<div class="mb-3">
    <button class="btn btn-primary" @onclick="() => OpenModal()">Add Transaction</button>
</div>

@* Search Input Field *@
@* <div class="mb-3"> *@
@*     <label for="searchTransactions" class="form-label">Search Transactions:</label> *@
@*     <input id="searchTransactions" *@
@*            type="text" *@
@*            list="transactionList" *@
@*            class="border-gray-300 p-lg-2 text-gray-800 w-full rounded-lg border transition-all focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" *@
@*            @oninput="OnSearchInputChanged" /> *@
@* </div> *@

<div class="mb-6 gap-6 grid grid-cols-1 md:grid-cols-3">
    @* Total Inflow *@
    <div class="bg-green-100 p-4 rounded shadow">
        <div class="align-center flex w-full justify-between">
            <p class="text-sm">Total Inflow</p>
            <p class="text-sm">@totalInflowTransactions</p>
        </div>
        <p class="text-lg font-semibold">
            @if (!FilteredTransactions.Any())
            {
                @* loggedin user currency *@
                <span>@userCurrency 0.00</span>
            }
            else
            {
                <span>@userCurrency @TotalInflow</span>
            }
        </p>
    </div>

    @* Total Outflow *@
    <div class="bg-red-100 p-4 rounded shadow">
        <div class="align-center flex w-full justify-between">
            <p class="text-sm">Total Outflow</p>
            <p class="text-sm">@totalOutflowTransactions</p>
        </div>
        <p class="text-lg font-semibold">
            @if (!FilteredTransactions.Any())
            {
                <span>@userCurrency 0.00</span>
            }
            else
            {
                <span>@userCurrency @TotalOutflow</span>
            }
        </p>
    </div>

    @* Net Balance *@
    <div class="bg-blue-100 p-4 rounded shadow">
        <div class="align-center flex w-full justify-between">
            <p class="text-sm">Total Transaction</p>
            <p class="text-sm">@totalTransactions</p>
        </div>
        <p class="text-lg font-semibold">
            @if (!FilteredTransactions.Any())
            {
                <span>@userCurrency 0.00</span>
            }
            else
            {
                <span>@userCurrency @TotalTransaction</span>
            }
        </p>
    </div>
</div>

@* Transactions Table *@
@if (FilteredTransactions == null || FilteredTransactions.Count == 0)
{
    <p>No transactions available.</p>
}
else
{
    <table class="table-striped table-bordered table">
        <thead class="thead-dark">
            <tr>
                <th>Title</th>
                <th>Amount</th>
                <th>Date</th>
                <th>Transaction Type</th>
                <th>Payment Method</th>
                <th>Tags</th>
                <th>Notes</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var transaction in AllTransactions)
            {
                <tr>
                    <td>@transaction.Title</td>
                    <td>@userCurrency @transaction.Amount</td>
                    <td>@transaction.Date.ToShortDateString()</td>
                    <td>@transaction.TransactionType</td>
                    <td>@transaction.PaymentMethod</td>
                    <td>@string.Join(", ", transaction.TagName)</td>
                    <td>@transaction.Notes</td>
                    <td>
                        <button class="btn btn-primary btn-sm" @onclick="() => OpenModal(transaction)">Edit</button>
                        <button class="btn btn-danger btn-sm" @onclick="() => DeleteTransaction(transaction)">Delete</button>
                    </td>
                </tr>
            }
        </tbody>
    </table>
}


@* Modal *@
@if (isModalVisible)
{
    <div class="modal d-block" tabindex="-1" style="background-color: rgba(0, 0, 0, 0.5);">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">@modalTitle</h5>
                    <button type="button" class="btn-close" @onclick="CloseModal" aria-label="Close"></button>
                </div>
                <div class="modal-body">

                    @if (!string.IsNullOrWhiteSpace(modalErrorMessage))
                    {
                        <div class="alert alert-danger">@modalErrorMessage</div>
                    }
                    <div class="mb-3">
                        <label for="transactionTitle" class="form-label">Title:</label>
                        <input id="transactionTitle" @bind="newTransaction.Title" class="form-control" />
                    </div>
                    <div class="mb-3">
                        <label for="transactionAmount" class="form-label">Amount:</label>
                        <input id="transactionAmount" @bind="newTransaction.Amount" type="number" class="form-control" />
                    </div>
                    <div class="mb-3">
                        <label for="transactionDate" class="form-label">Date:</label>
                        <input id="transactionDate" @bind="newTransaction.Date" type="date" class="form-control" />
                    </div>
                    <div class="mb-3">
                        <label for="transactionType" class="form-label">Transaction Type:</label>
                        <select id="transactionType" @bind="newTransaction.TransactionType" class="form-control">
                            <option value=""> -- Select -- </option>
                            <option value="Debit">Debit</option>
                            <option value="Credit">Credit</option>
                            <option value="Debt" disabled>Debt</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="paymentMethod" class="form-label">Payment Method:</label>
                        <select id="paymentMethod" @bind="newTransaction.PaymentMethod" class="form-control">
                            <option value=""> -- Select -- </option>
                            <option value="Cash">Cash</option>
                            <option value="Card">Card</option>
                            <option value="BankTransfer">Bank Transfer</option>
                            <option value="MobilePayment">Mobile Payment</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="Tags" class="text-gray-700 block text-lg font-medium">Tags:</label>
                        <input id="Tags"
                        type="text"
                        @bind="newTransaction.TagName"
                        list="tagList"
                        class="border-gray-300 p-lg-2 text-gray-800 w-full rounded-lg border transition-all focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        @oninput="OnTagInputChanged" />

                        @* The datalist element will show available tags as suggestions *@
                        <datalist id="tagList">
                            @foreach (var tag in filteredTags)
                            {
                                <option value="@tag.Name" />
                            }
                        </datalist>
                    </div>


                    <div class="mb-3">
                        <label for="transactionNotes" class="form-label">Notes:</label>
                        <textarea id="transactionNotes" @bind="newTransaction.Notes" class="form-control"></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CloseModal">Cancel</button>
                    <button type="button" class="btn btn-success" @onclick="AddOrUpdateTransaction">@modalButtonText</button>
                </div>
            </div>
        </div>
    </div>
}


@code {
    string userName = string.Empty;
    string userCurrency = string.Empty;
    double userBalance = 0.00;

    private double TotalInflow { get; set; }
    private double TotalOutflow { get; set; }
    private double TotalTransaction => TotalInflow + TotalOutflow;

    private int totalInflowTransactions = 0;
    private int totalOutflowTransactions = 0;
    private int totalTransactions = 0;

    private List<Transactions> AllTransactions { get; set; } = new List<Transactions>();
    // initialize new transaction to be added
    private List<Tags> AllTags { get; set; } = new List<Tags>();
    private List<Tags> filteredTags { get; set; } = new List<Tags>();

    private string LoggedInUserName { get; set; }
    private List<Transactions> FilteredTransactions { get; set; } = new List<Transactions>();
    private Transactions newTransaction = new Transactions();


    // Filter and search
    // private string searchQuery = string.Empty;
    private string transactionTypeFilter = string.Empty;
    private string tagFilter = string.Empty;
    public DateTime? startDateFilter { get; set; }
    public DateTime? endDateFilter { get; set; }

    // initialize value for if a user is editing a transaction
    private bool isEditing = false;
    // Modal values
    private bool isModalVisible = false;
    private string modalTitle = "Add New Transaction";
    private string modalButtonText = "Add Transaction";

    //initialize value for error message
    private string? errorMessage;
    private string? modalErrorMessage;

    protected override async Task OnInitializedAsync()
    {
        PageTitleService.PageTitle = "Transaction Overview";
        AllTags = await TagService.LoadAllTagsAsync();
        // Get the logged-in user's Name
        var loggedInUser = await MapUser.GetUserByUsernameAsync(Storage);
        if (loggedInUser != null)
        {
            LoggedInUserName = loggedInUser.Name;
        }

        userName = loggedInUser.UserName;
        userBalance = loggedInUser.Balance;
        userCurrency = loggedInUser.CurrencyCode;

        // Load transactions and filter for the ogged-in user

        await LoadTransactions();

        FilterTransactions();

    }

    private void ApplyFilters()
    {
        FilterTransactions();
    }


    private void FilterTransactions()
    {
        // Start with all transactions
        var filteredTransactions = AllTransactions.Where(t => t.UserName == userName);

        // Apply each filter condition if the filter is not null or empty
        if (!string.IsNullOrEmpty(transactionTypeFilter))
        {
            filteredTransactions = filteredTransactions.Where(t => t.TransactionType == transactionTypeFilter);
        }

        if (!string.IsNullOrEmpty(tagFilter))
        {
            filteredTransactions = filteredTransactions.Where(t => t.TagName.Contains(tagFilter, StringComparison.OrdinalIgnoreCase));
        }

        if (startDateFilter.HasValue)
        {
            filteredTransactions = filteredTransactions.Where(t => t.Date >= startDateFilter.Value);
        }

        if (endDateFilter.HasValue)
        {
            filteredTransactions = filteredTransactions.Where(t => t.Date <= endDateFilter.Value);
        }

        // After all filters are applied, convert to a list
        FilteredTransactions = filteredTransactions.ToList();


        UpdateTotals();
    }

    private void UpdateTotals()
    {
        if (FilteredTransactions.Any())
        {
            TotalInflow = FilteredTransactions
                .Where(t => t.TransactionType == "Credit")
                .Sum(t => t.Amount);

            TotalOutflow = FilteredTransactions
                .Where(t => t.TransactionType == "Debit")
                .Sum(t => t.Amount);

            totalInflowTransactions = FilteredTransactions.Where(t => t.TransactionType == "Credit").Count();
            totalOutflowTransactions = FilteredTransactions.Where(t => t.TransactionType == "Debit").Count();
            totalTransactions = FilteredTransactions.Count();
        }
        else
        {
            TotalInflow = TotalOutflow = totalInflowTransactions = totalOutflowTransactions = totalTransactions = 0;
        }
    }



    // for retrieving existing transactions
    private async Task LoadTransactions()
    {
        try
        {
            errorMessage = null;

            // Fetch the latest transactions and filter for the logged-in user
            AllTransactions = await TransactionService.LoadAllTransactionsAsync();

        }
        catch (Exception ex)
        {
            errorMessage = $"An error occurred while loading transactions: {ex.Message}";
        }
    }


    // private async Task OnSearchInputChanged(ChangeEventArgs e)
    // {
    //     var typedTitle = e.Value?.ToString();

    //     if (string.IsNullOrWhiteSpace(typedTitle))
    //     {
    //         FilteredTransactions = AllTransactions;
    // //Show all transactions when input is empty
    //         return;
    //     }

    //    // Filter existing transactions based on the user's input
    //     FilteredTransactions = AllTransactions.Where(t => t.Title.Contains(typedTitle, StringComparison.OrdinalIgnoreCase)).ToList();
    // }

    private void OpenModal(Transactions? transaction = null)
    {
        if (transaction != null)
        {
            newTransaction = new Transactions
                {
                    Id = transaction.Id,
                    User = transaction.User,
                    UserName = transaction.UserName,
                    Title = transaction.Title,
                    Amount = transaction.Amount,
                    Date = transaction.Date,
                    TransactionType = transaction.TransactionType,
                    PaymentMethod = transaction.PaymentMethod,
                    Tags = transaction.Tags,
                    TagName = transaction.TagName,
                    Notes = transaction.Notes
                };
            isEditing = true;
            modalTitle = "Edit Transaction";
            modalButtonText = "Save Changes";
        }
        else
        {
            newTransaction = new Transactions();
            isEditing = false;
            modalTitle = "Add New Transaction";
            modalButtonText = "Add Transaction";
        }

        isModalVisible = true;
    }

    private void CloseModal()
    {
        isModalVisible = false;
        ResetForm();
    }

    private async Task OnTagInputChanged(ChangeEventArgs e)
    {
        var typedTag = e.Value?.ToString();

        if (string.IsNullOrWhiteSpace(typedTag))
        {
            filteredTags = AllTags;  // Show all tags when input is empty
            return;
        }

        // Filter existing tags based on the user's input
        filteredTags = AllTags.Where(t => t.Name.Contains(typedTag, StringComparison.OrdinalIgnoreCase)).ToList();
    }

    private async Task CheckAndAddTag()
    {
        if (string.IsNullOrWhiteSpace(newTransaction.TagName)) return;

        var existingTag = AllTags.FirstOrDefault(t => t.Name.Equals(newTransaction.TagName, StringComparison.OrdinalIgnoreCase));

        if (existingTag == null)
        {
            // The tag is not found, so add it as a new tag
            var newTag = new Tags { Name = newTransaction.TagName };
            AllTags.Add(newTag);

            await TagService.SaveTagAsync(newTag);

            // Update the Tag object in the transaction model
            newTransaction.Tags = newTag;
        }
        else
        {
            // Set the tag to the existing tag
            newTransaction.Tags = existingTag;
        }
    }

    private void SelectTag(string tagName)
    {
        // Set the tagName directly from the list of existing tags
        newTransaction.TagName = tagName;
        var selectedTag = AllTags.FirstOrDefault(t => t.Name == tagName);
        if (selectedTag != null)
        {
            newTransaction.Tags = selectedTag;
        }
    }

    private async Task AddOrUpdateTransaction()
    {
        if (string.IsNullOrWhiteSpace(newTransaction.Title) || newTransaction.Amount <= 0)
        {
            modalErrorMessage = "Title and Amount must be provided, and Amount must be greater than zero.";
            return;
        }

        if (string.IsNullOrWhiteSpace(newTransaction.TransactionType))
        {
            modalErrorMessage = "Transaction type must be selected";
            return;
        }

        if (string.IsNullOrWhiteSpace(newTransaction.PaymentMethod))
        {
            modalErrorMessage = "Payment method must be selected";
            return;
        }

        try
        {
            // Get the logged-in user
            var loggedInUser = await MapUser.GetUserByUsernameAsync(Storage);

            // If we are editing an existing transaction
            if (isEditing)
            {
                // Find the existing transaction from the database or storage (replace with actual loading logic)
                var existingTransaction = await TransactionService.GetTransactionByIdAsync(newTransaction.Id);

                // Undo the balance change caused by the previous transaction
                if (existingTransaction != null)
                {
                    if (existingTransaction.TransactionType == "Debit")
                    {
                        loggedInUser.Balance += existingTransaction.Amount;  // Revert debit
                    }
                    else if (existingTransaction.TransactionType == "Credit")
                    {
                        loggedInUser.Balance -= existingTransaction.Amount;  // Revert credit
                    }
                }
            }

            // Update the balance based on the new transaction type
            if (newTransaction.TransactionType == "Debit")
            {
                if (newTransaction.Amount > loggedInUser.Balance)
                {
                    modalErrorMessage = "Insufficient balance for this debit transaction.";
                    return;
                }
                loggedInUser.Balance -= newTransaction.Amount;  // Deduct the amount for debit
            }
            else if (newTransaction.TransactionType == "Credit")
            {
                loggedInUser.Balance += newTransaction.Amount;  // Add the amount for credit
            }

            // Update the logged-in user balance
            newTransaction.User = loggedInUser;
            newTransaction.UserName = loggedInUser.UserName;

            // Handle the transaction tags
            var selectedTag = AllTags.FirstOrDefault(t => t.Name == newTransaction.TagName);
            if (selectedTag == null && !string.IsNullOrWhiteSpace(newTransaction.TagName))
            {
                var newTag = new Tags
                    {
                        Id = AllTags.Count > 0 ? AllTags.Max(t => t.Id) + 1 : 1,
                        Name = newTransaction.TagName
                    };

                AllTags.Add(newTag);
                await TagService.SaveTagAsync(newTag);

                selectedTag = newTag;
            }

            if (selectedTag != null)
            {
                newTransaction.Tags = selectedTag;
            }

            // Save the updated transaction
            if (isEditing)
            {
                await TransactionService.UpdateTransactionAsync(newTransaction);  // Update the transaction
            }
            else
            {
                await TransactionService.SaveTransactionAsync(newTransaction);  // Save a new transaction
            }

            modalErrorMessage = null; // Clear error

            // Update the user record with the new balance
            await UserService.UpdateUserAsync(loggedInUser);
            UpdateTotals();

            // Load the updated transactions and close the modal
            await LoadTransactions();
            CloseModal();
        }
        catch (Exception ex)
        {
            modalErrorMessage = $"Error saving transaction: {ex.Message}";
        }
    }

    private async Task DeleteTransaction(Transactions transaction)
    {
        try
        {
            // Get the logged-in user
            var loggedInUser = await MapUser.GetUserByUsernameAsync(Storage);

            // Adjust the balance based on the type of the transaction (Credit or Debit)
            if (transaction.TransactionType == "Credit")
            {
                loggedInUser.Balance -= transaction.Amount;  // Deduct the amount for credit
            }
            else if (transaction.TransactionType == "Debit")
            {
                loggedInUser.Balance += transaction.Amount;  // Add the amount for debit
            }

            await UserService.UpdateUserAsync(loggedInUser);
            await TransactionService.DeleteTransactionAsync(transaction);
            UpdateTotals();
            await LoadTransactions();
        }
        catch (Exception ex)
        {
            errorMessage = $"Error deleting transaction: {ex.Message}";
        }
    }

    private void ResetForm()
    {
        newTransaction = new Transactions();
        isEditing = false;
        errorMessage = null;
    }
}